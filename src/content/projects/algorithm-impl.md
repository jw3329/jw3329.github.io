---
title: "Algorithm Implementation"
description: "20+ classic algorithms implemented in Python Jupyter notebooks — DP, graph algorithms, greedy, sorting, and divide & conquer."
date: 2019-01-18
tech: ["Python", "Jupyter Notebook", "NumPy", "Algorithms"]
github: "https://github.com/jw3329/algorithm-implementation"
featured: false
---

A comprehensive collection of classic algorithm implementations in Python, organized by technique and presented as interactive Jupyter notebooks.

## What's covered

| Technique | Algorithms |
|-----------|-----------|
| **Dynamic Programming** | 0-1 Knapsack, Edit Distance, Longest Common Subsequence, Longest Increasing Subsequence, Subset Sum, Optimal BST, Partition Problem, Matrix Longest Path |
| **Graph** | BFS, DFS, Dijkstra's Shortest Path, Topological Sort |
| **Greedy** | Huffman Coding, Job Sequencing with Deadlines, Fractional Knapsack |
| **Sorting** | Merge Sort, Quick Sort, Quickselect, Bubble Sort, Bucket Sort, Selection Sort |
| **Divide & Conquer** | Strassen Matrix Multiplication |

## Design

Each notebook includes problem statements, step-by-step explanations, and example runs. The interactive format lets you run and experiment with the code directly — ideal for learning and reference.

## Why Jupyter?

Notebooks bridge the gap between documentation and executable code. Each algorithm is both an explanation and a runnable implementation, making this a living reference for algorithmic techniques.
